import math
import random

import numpy as np
import pandas as pd

import wandb

from black76.parameters import *
import black76.model as pricing

# ####################################################################
# PARAMETERS
# ####################################################################

FUTURES_FEE_LEVEL = 0.0010  # in theory 5 bps, but with b/o spread and all...


# ####################################################################
# HEDGED OPTION POSITION CLASS
# ####################################################################

class HedgedOptionPosition(object):
    #
    #
    instances_created = 0

    def __init__(self,
                 option_type: int,
                 notional: float,
                 strike_moneyness: float,
                 extrinsic_features: pd.DataFrame,
                 window_size: int = 60,
                 risk_aversion: float = 1.0
                 ):

        self.option_type: int = int(option_type)
        assert option_type in {-1, 1}

        self.risk_aversion = risk_aversion

        self.strike_moneyness: float = float(strike_moneyness)

        self.notional = float(notional)
        self.extrinsic_features = extrinsic_features
        self.extrinsic_features_count = self.extrinsic_features.shape[1]
        self.expiry_offset = self.extrinsic_features.shape[0]

        self.window_size: int = int(window_size)
        assert window_size > 0

        # Time related
        self.start_ts = None
        self.expiry_ts = None
        self.duration_minutes = None

        # Strike (in crypto-units)
        self.strike = np.nan
        self.spot_on_strike = np.nan

        # Cashflow generated by initial transaction (+/-)
        self.cash_balance = np.nan
        self.option_premium = np.nan

        # Hedging
        self.hedge_size = 0.0
        self.hedge_price = 0.0
        self.hedge_realized_pnl = 0.0
        self.hedge_trades = []
        self.hedge_cashflows = []
        self.hedge_fees = 0.0

        # Hedge by chunk of 10% of notional exposure
        self.hedge_rel_step = 0.10  # 10%
        self.hedge_abs_step = math.fabs(self.hedge_rel_step * self.notional)

        self.delta_hedge_sign = -1.0 * np.sign(self.notional) * np.sign(self.option_type)

        self.greeks = None

        # Previous encodings
        self.prev_enc_in = None
        self.prev_enc_ex = None

        self.payoff_at_expiry = 0.0
        self.hedge_unwind_at_expiry = 0.0

        self.mtm_accreted = 0.0
        self.reward = 0.0

        self.is_displayed = False

    # ####################################################################
    # FORCED ACTION: STRIKE THE OPTION
    # ####################################################################

    def reset(self):

        self.instances_created += 1
        self.is_displayed = random.randint(0, 100) < 10

        self.cash_balance = 0.0

        # Get the time vector
        start_ts, expiry_ts, ttm = self.compute_ttm()
        self.start_ts, self.expiry_ts = start_ts, expiry_ts

        # Spot time series
        spot_vec = self.extrinsic_features.perpetual

        # Spot time series
        iv_vec = self.extrinsic_features.iv_atm_1440

        # Contextual: strike
        spot_on_strike = spot_vec[self.window_size]
        self.extrinsic_features["close_scaled"] = (self.extrinsic_features.perpetual / spot_on_strike).copy()

        self.spot_on_strike = round(spot_on_strike, 0)
        k = round(self.strike_moneyness * spot_on_strike, 4)
        self.strike = k

        strike_vec = np.ones_like(spot_vec) * k
        greeks, option_cf = self.pre_compute_greeks(spot=spot_vec,
                                                    strike=strike_vec,
                                                    ttm=ttm,
                                                    iv=iv_vec)
        self.greeks = greeks
        self.cash_balance += option_cf

        # Premium obtained/paid for selling/buying the option
        self.option_premium = option_cf

        # Initial hedge
        offset = self.window_size - 1

        tgt_delta = -1.0 * self.greeks[offset, 6] * self.notional
        delta_0 = round(round(tgt_delta / self.hedge_abs_step) * self.hedge_abs_step, 4)

        self.hedge_size = delta_0
        self.hedge_price = spot_on_strike

        # For the records
        self.hedge_trades.append((spot_on_strike, delta_0, offset, self.hedge_size, tgt_delta))

        # Update cash balance
        fees = FUTURES_FEE_LEVEL * math.fabs(delta_0)
        self.hedge_fees += fees
        self.cash_balance -= math.fabs(fees)

        # Cash

        self.mtm_accreted = 0.0

    # ####################################################################
    # ANALYTICS
    # ####################################################################

    @property
    def expiry_mtm(self):
        return self.cash_balance

    @property
    def hedge_increase_count(self):
        inc_hdg = [h for h in self.hedge_trades if h[1] > 0.0]
        return len(inc_hdg)

    @property
    def hedge_decrease_count(self):
        dec_hdg = [h for h in self.hedge_trades if h[1] < 0.0]
        return len(dec_hdg)

    @property
    def hedge_total_count(self):
        if self.hedge_trades is None or not len(self.hedge_trades):
            return 0
        return len(self.hedge_trades)

    @property
    def hedge_total_cashflow(self):
        if len(self.hedge_cashflows) > 0:
            return sum(self.hedge_cashflows)
        return 0.0

    # ####################################################################
    # MARKET DATA
    # ####################################################################

    def get_close(self, offset: int, end_offset: int = None):
        if end_offset is None:
            return float(self.extrinsic_features.perpetual[offset])
        return self.extrinsic_features.perpetual[offset:end_offset].to_numpy()

    def get_implied_vol(self, offset: int, end_offset: int = None):
        if end_offset is None:
            iv = float(self.extrinsic_features.iv_atm_1440[offset])
            # iv = 0.6

        else:
            iv = self.extrinsic_features.iv_atm_1440[offset:end_offset].to_numpy()
            # iv = np.ones(end_offset-offset,) * 0.6

        iv[np.isnan(iv)] = 0.6

        iv = np.clip(iv, EPSILON_IV, 1e9)
        return iv

    # ####################################################################
    # FORCED ACTION: EXPIRE
    # ####################################################################

    def mark_to_market(self, offset: int):

        # Adjust for our warmup time
        offset += self.window_size

        # Our current spot level
        spot = self.extrinsic_features.perpetual[offset]

        if not len(self.hedge_trades):
            fut_pnl = 0.0

        else:
            fut_pnl = sum([h[1] * (1.0 - h[0] / spot) for h in self.hedge_trades])

        # Update the greeks depending on futures trading
        greeks = self.greeks
        #

        # Greek 15: hedge's pnl
        greeks[offset, 15] = fut_pnl

        # Greek 16: hedge's price
        if math.fabs(self.hedge_size) > 1e-12:
            greeks[offset, 16] = spot / self.hedge_price - 1.0

        # Greek 17: hedge's size
        greeks[offset, 17] = self.hedge_size

        # Greek 18: account mtm
        opt_mtm = greeks[offset, 4]
        cash_balance = self.cash_balance
        hdg_cf = sum(self.hedge_cashflows)
        account_mtm = fut_pnl - opt_mtm + cash_balance + hdg_cf
        greeks[offset, 18] = account_mtm

        # Greek 19: max total pnl
        tgt_delta = -1.0 * self.notional * greeks[offset, 6]
        cur_delta = self.hedge_size
        net_delta = cur_delta - tgt_delta
        greeks[offset, 19] = net_delta

        # Greek 20: cur pnl w.r.t. max pnl observed
        greeks[offset, 20] = np.max(greeks[:, 18]) - account_mtm

        # Incremental return
        mtm_increment = greeks[offset, 18] - greeks[offset - 1, 18]

        # Accretion of MtM
        self.mtm_accreted += mtm_increment

        # return reward
        reward = -0.5 * self.risk_aversion * net_delta ** 2  # + mtm_increment
        self.reward += reward
        return reward

    def compute_payoff(self, spot: float):
        return max(0.0, self.option_type * (spot - self.strike)) / spot

    # ####################################################################
    # FORCED ACTION: EXPIRE
    # ####################################################################

    def is_expired(self, offset: int):
        return offset >= self.expiry_offset

    def expire(self, offset: float):

        # Adjust for our warmup time
        offset += self.window_size

        # Get our closing level and strike
        strike = self.strike
        spot = self.extrinsic_features.perpetual[offset]

        # Compute the raw payoff of this option
        option_payoff = self.notional * max(0.0, self.option_type * (spot - strike)) / spot
        self.payoff_at_expiry = option_payoff

        # Update cash balance
        self.cash_balance += option_payoff

        # Compute hedge fees for final unwind
        fees = FUTURES_FEE_LEVEL * math.fabs(self.hedge_size)
        self.hedge_fees += fees

        # Update cash balance
        self.cash_balance -= math.fabs(fees)

        # Hedge payoff
        hedge_payoff = self.hedge_size * (spot - self.hedge_price) / spot
        self.hedge_unwind_at_expiry = hedge_payoff

        # Update cash balance
        self.cash_balance += hedge_payoff

        # Close out
        self.hedge_cashflows.append(hedge_payoff)

        tgt_delta = -1.0 * self.notional * self.greeks[offset, 6]

        # For the records
        self.hedge_trades.append((spot, -1.0 * self.hedge_size, offset, self.hedge_size, tgt_delta))

        hdg_tx_count = int(self.hedge_total_count)
        if not hdg_tx_count:
            hedging_life_cf = 0.0
        else:
            hedging_life_cf = sum(self.hedge_cashflows[:-1])

        # Greek 18: account mtm
        self.greeks[offset, 18] = self.cash_balance

        # MtM accreted
        mtm_increment = self.greeks[offset, 18] - self.greeks[offset - 1, 18]
        self.mtm_accreted += mtm_increment

        info = {
            "accreted_mtm_bps": round(10000.0 * self.mtm_accreted, 2),
            "end_cash_bps": round(10000.0 * self.cash_balance, 2),
            "hdg_cf_adjusts_bps": 10000.0 * hedging_life_cf,
            "hdg_trades_pct": self.hedge_total_count / self.duration_minutes,
            "net_payoff_bps": 10000.0 * (hedge_payoff - option_payoff),
            "duration_hrs": self.duration_minutes / 60,
            "train_episode_reward": self.reward,
            "risk_aversion": self.risk_aversion,
        }
        wandb.log(info)

        if self.is_displayed:
            #
            t_ = "Call" if self.option_type > 0.0 else "Put"
            m_ = round(100.0 * self.strike_moneyness, 2)
            ti_ = f"{int(self.duration_minutes)} min" if self.duration_minutes < 120 else f"{round(self.duration_minutes / 60, 2)} hrs"
            lg = "Long" if self.notional > 0.0 else "Short"
            print(f"[SUMMARY] {lg} {t_} option @ {m_}% expiring on {self.expiry_ts} after {ti_}.")
            print(f"Account MtM on Expiry: {round(10000.0 * self.cash_balance, 2)} bps")
            #
            print(f"    >> Premium: {round(10000.0 * self.option_premium, 2)} bps")
            print(f"    >> Hedge: {round(10000.0 * hedge_payoff, 2)} bps")
            print(f"    >> Payoff: {round(10000.0 * option_payoff, 2)} bps")
            print(f"    >> MtM Accreted: {round(10000.0 * self.mtm_accreted, 2)} bps")

            print(f"    >> Risk aversion: {self.risk_aversion}")
            print(f"    >> Episode Reward: {self.reward}")

            # Hedging actions taken
            print(f"    >> Initial delta: {round(100.0 * self.greeks[self.window_size, 6] * self.notional, 2)}%")
            print(f"    >> Hedging trades performed: {hdg_tx_count}")
            print(f"    >> Hedging trades fees paid: {round(10000.0 * self.hedge_fees, 2)} bps.")

            print(f"    >> Hedging to all actions: {round(100 * hdg_tx_count / self.duration_minutes, 1)}%")
            print(f"    >> Hedging cashflows (excluding final unwind): {round(10000.0 * hedging_life_cf, 2)} bps")

            print(f"    >> Strike: {self.strike}")
            print(f"    >> Spot on strike: {self.spot_on_strike}")
            print(f"    >> Spot at expiry: {spot}")

            print(f"Hedging trades:")
            for tx in self.hedge_trades:
                px, qty, idx, dl, tgt = tx[0], tx[1], tx[2], tx[3], tx[4]
                d = "Sell" if qty < 0.0 else "buy"
                print(
                    f"    >> [{idx}] {d} {math.fabs(qty)} at {px}: {round(100.0 * dl)}% vs target {round(100.0 * tgt)}%")

            print("~" * 100)

        # Greek 19: max total pnl
        greeks = self.greeks
        tgt_delta = -1.0 * self.notional * greeks[offset, 6]
        net_delta = self.hedge_size - tgt_delta
        greeks[offset, 19] = net_delta

        reward = -0.5 * self.risk_aversion * net_delta ** 2 # + self.cash_balance
        self.reward += reward
        return reward

    # ####################################################################
    # ACTION: MODIFY HEDGE: BUY --> GO LONG(ER)
    # ####################################################################

    def buy_perpetual(self, offset: int):

        # Adjust for our warmup time
        offset += self.window_size

        hedge_ratio = self.hedge_size / math.fabs(self.notional)
        # Already maxed out
        if hedge_ratio >= 1.0:
            return 0.0

        hedge_direction = np.sign(self.hedge_size)

        # One increment in hedge space
        hedge_step = math.fabs(self.hedge_abs_step)

        projected_hedge = hedge_step + self.hedge_size
        if math.fabs(projected_hedge) < 1e-6:
            pass

        elif np.sign(projected_hedge) != self.delta_hedge_sign:
            return 0.0

        elif math.fabs(projected_hedge) > 1.0:
            return 0.0

        spot = self.extrinsic_features.perpetual[offset]

        # Store some infos to be updated
        prev_size, prev_price, cashflow = float(self.hedge_size), float(self.hedge_price), 0.0

        # We're buying the perpetual
        self.hedge_size += hedge_step

        if hedge_direction >= 0.0:  # dilution of current hedge
            is_increase = True
            self.hedge_price = (prev_price * prev_size + hedge_step * spot) / (hedge_step + prev_size)

        else:  # reducing generates a cashflow
            # raise NotImplementedError()
            # cashflow = prev_size * (spot - prev_price) / spot  #  TODO: hedge_step ???
            cashflow = hedge_step * (spot - prev_price) / spot
            is_increase = False

        tgt_delta = -1.0 * self.notional * self.greeks[offset, 6]

        # For the records
        self.hedge_trades.append((float(spot), float(hedge_step), offset, self.hedge_size, tgt_delta))

        fees = FUTURES_FEE_LEVEL * math.fabs(hedge_step)
        self.hedge_fees += fees

        self.hedge_cashflows.append(cashflow - fees)

        self.cash_balance += cashflow - fees

        if self.is_displayed:
            inc = "INCREASE" if is_increase else "DILUTION"
            cf = round(10000.0 * cashflow, 2)
            print(f"[{offset}] [{inc}] >> Previous: {round(prev_size, 2)} @ {round(prev_price, 2)}.")
            print(f"[{offset}] [{inc}] >> Current: {round(self.hedge_size, 2)} @ {round(self.hedge_price, 2)}.")
            print(f"[{offset}] [{inc}] >> Trade (buy) {hedge_step} @ {round(spot, 2)}.")
            print(f"[{offset}] [{inc}] >> Cashflow: {cf} bps.\n")

        return fees

    # ####################################################################
    # ACTION: MODIFY HEDGE: SELL --> GO SHORT(ER)
    # ####################################################################

    def sell_perpetual(self, offset: int):

        # Adjust for our warmup time
        offset += self.window_size

        hedge_ratio = self.hedge_size / math.fabs(self.notional)

        # Already maxed out on shorts
        if hedge_ratio <= -1.0:
            return 0.0

        hedge_direction = np.sign(self.hedge_size)

        # One increment in hedge space
        hedge_step = -1.0 * self.hedge_abs_step

        projected_hedge = hedge_step + self.hedge_size
        if math.fabs(projected_hedge) < 1e-6:
            pass

        elif np.sign(projected_hedge) != self.delta_hedge_sign:
            return 0.0

        elif math.fabs(projected_hedge) > 0.9999:
            return 0.0

        # Context
        spot = self.extrinsic_features.perpetual[offset]

        # Store some infos to be updated
        prev_size, prev_price, cashflow = float(self.hedge_size), float(self.hedge_price), 0.0

        # We're selling the perpetual
        self.hedge_size += hedge_step

        if hedge_direction <= 0.0:  # dilution of current hedge
            self.hedge_price = (prev_price * prev_size + hedge_step * spot) / (hedge_step + prev_size)
            is_increase = True

        else:  # reducing generates a cashflow
            # cashflow = prev_size * (spot - prev_price) / spot   #  TODO: hedge_step ???
            cashflow = -1.0 * hedge_step * (spot - prev_price) / spot
            is_increase = False

        # For the records
        # self.hedge_trades.append((float(spot), float(hedge_step), offset))

        tgt_delta = -1.0 * self.notional * self.greeks[offset, 6]

        # For the records
        self.hedge_trades.append((float(spot), float(hedge_step), offset, self.hedge_size, tgt_delta))

        fees = FUTURES_FEE_LEVEL * math.fabs(hedge_step)
        self.hedge_fees += fees

        self.hedge_cashflows.append(cashflow - fees)

        self.cash_balance += cashflow - fees

        if self.is_displayed:
            inc = "INCREASE" if is_increase else "DILUTION"
            cf = round(10000.0 * cashflow, 2)
            print(f"[{offset}] [{inc}] >> Previous: {round(prev_size, 2)} @ {round(prev_price, 2)}.")
            print(f"[{offset}] [{inc}] >> Current: {round(self.hedge_size, 2)} @ {round(self.hedge_price, 2)}.")
            print(f"[{offset}] [{inc}] >> Trade (sell) {hedge_step} @ {round(spot, 2)}.")
            print(f"[{offset}] [{inc}] >> Cashflow: {cf} bps.\n")
        return fees

    # ####################################################################
    # ENCODE DATA
    # ####################################################################

    def encode(self, offset: int):

        # Adjust for our warmup time
        offset += self.window_size

        encodings_ex = self.encode_extrinsic(offset)
        encodings_ex = self.pandas_fill(encodings_ex)

        encodings_in = self.encode_intrinsic(offset)
        encodings_in = self.pandas_fill(encodings_in)

        try:

            nan_count = np.count_nonzero(np.isnan(encodings_ex))
            if nan_count > 0:
                print(f"Found NaN in extrinsic encoded data.")
                # encodings_ex = self.pandas_fill(encodings_ex)

            nan_count = np.count_nonzero(np.isnan(encodings_in))
            if nan_count > 0:
                print(f"Found NaN in intrinsic encoded data.")
                # encodings_in = self.pandas_fill(encodings_in)

            self.prev_enc_in = encodings_ex
            self.prev_enc_ex = encodings_in

            return np.concatenate([encodings_ex, encodings_in], axis=0).astype(np.float32)

        except Exception as exc:
            print(exc)

    def encode_extrinsic(self, offset: int):

        # Select start and stop indices
        # start, stop = offset - (self.window_size - 1), offset + 1
        start, stop = offset - self.window_size, offset

        # cols = ["open", "high", "low", "close_scaled"]
        # return self.extrinsic_features[cols][start:stop].to_numpy().transpose()

        return self.extrinsic_features[start:stop].to_numpy().transpose()

    def encode_intrinsic(self, offset: int):
        # Backward-looking observations
        # start, stop = offset, offset + self.window_size
        start, stop = offset - self.window_size, offset
        observed_greeks = self.greeks[start:stop, :]
        return observed_greeks.transpose()

    @classmethod
    def pandas_fill(cls, arr):
        df = pd.DataFrame(arr)
        df.fillna(method='ffill', axis=1, inplace=True)
        return df.to_numpy()

    # ####################################################################
    # PRE-COMPUTING GREEKS
    # ####################################################################

    def compute_ttm(self, ):

        expiry_ts = self.extrinsic_features.index[-1]
        start_ts = self.extrinsic_features.index[self.window_size]

        # Get a duration for this option's life
        duration_in_minutes = int((expiry_ts - start_ts).total_seconds() / 60.0)
        self.duration_minutes = duration_in_minutes

        ttm_plus_warmup = np.arange(duration_in_minutes + self.window_size, -1, -1) / MINUTES_PER_YEAR
        ttm_plus_warmup[-1] = EPSILON_TTM  # avoids zero

        return start_ts, expiry_ts, ttm_plus_warmup

    def pre_compute_greeks(self,
                           spot: np.ndarray,
                           strike: np.ndarray,
                           ttm: np.ndarray,
                           iv: np.ndarray, ):

        # Greeks by index:
        #
        # 0: option_type        # 5: exercise probability           # 10: strike moneyness: k(t) / s(t)
        # 1: df                 # 6: delta                          # 11: Option position mark-to-market
        # 2: d_1                # 7: vega                           # 12: Extrinsic optionality value
        # 3: d_2                # 8: gamma                          # 13: Notional sign (long: +1, short: -1)
        # 4: price              # 9: spot moneyness: s(t) / s(0)    # 14: TTM
        #
        # 15: hedge's pnl       # 20: cur rel pnl wrt max
        # 16: hedge's px perf   # 21: prem acc tgt
        # 17: hedge's size      #
        # 18: account mtm
        # 19: net delta expo
        #
        # Total:
        greeks_nb = 22

        # Some variables
        win_size = self.window_size
        reference_spot = spot[win_size]
        #
        output = np.zeros((ttm.shape[0], greeks_nb))

        # Notional
        notional = self.notional
        notional_sign = np.sign(notional)

        # Position 0: OPTION TYPE (+/- 1)
        option_type = self.option_type
        output[:, 0] = option_type * notional_sign

        # Position 1: DISCOUNT FACTOR
        no_discount = np.ones_like(ttm)
        output[:, 1] = no_discount

        # TODO; Remove this.... !!!!!!!!!!11
        # iv = 5 * iv

        # Compute the d1 and d2 vectors (along the time axis)
        d1, d2 = pricing.compute_d1_and_d2(forward=spot,
                                           strike=strike,
                                           volatility=iv,
                                           ttm=ttm,
                                           df=no_discount)

        # Position 2 and 3: NORMALIZED D1 AND D2
        min_clip, max_clip = -2.0, 2.0
        output[:, 2] = (d1 * 0.1).clip(min_clip, max_clip)
        output[:, 3] = (d2 * 0.1).clip(min_clip, max_clip)

        abs_price, delta, proba = pricing.price_delta_proba(option_type=option_type,
                                                            forward=spot,
                                                            strike=strike,
                                                            d1=d1,
                                                            d2=d2,
                                                            df=no_discount)

        price = np.divide(abs_price, spot)

        # Position 4 to 6: PRICE, PROBA, DELTA
        output[:, 4] = price
        output[:, 5] = proba
        output[:, 6] = delta

        # Position 7 and 8: VEGA AND GAMMA
        vega, gamma = pricing.vega_and_gamma(forward=spot,
                                             strike=strike,
                                             volatility=iv,
                                             ttm=ttm,
                                             d2=d2,
                                             df=no_discount)
        output[:, 7] = vega * 0.01
        output[:, 8] = gamma * notional_sign

        # Position 9: SPOT MONEYNESS
        output[:, 9] = np.divide(spot, reference_spot) - 1.0

        # Position 10: STRIKE MONEYNESS
        output[:, 10] = (np.divide(strike, spot) - 1.0) * option_type

        # Position 10: OPTION MARK-TO-MARKET
        initial_cf = price[self.window_size] * notional * -1.0  # notional < 0 => sell option => positive cashflow
        if math.fabs(initial_cf) < 0.0005:
            if self.notional > 0.0:  # long
                initial_cf = -0.0005
                # print(f"Initial cashflow reset to -5 bps.")
            else:
                initial_cf = 0.0005
                # print(f"Initial cashflow reset to 5 bps.")

        # Position 11: Option position mark-to-market
        output[:, 11] = np.divide(initial_cf + (price * notional), initial_cf)

        # Position 12: Extrinsic option value
        output[:, 12] = price - np.divide(np.floor(option_type * (spot - strike)), spot)

        # Position 13: Notional sign
        output[:, 13] = notional_sign

        # Position 14: Time To Maturity
        output[:, 14] = ttm

        # Position 15: HEDGE'S PNL (computed at runtime)
        output[:, 15] = 0.0

        # Position 16: HEDGE'S PRICE PERFORMANCE (computed at runtime)
        # output[0:win_size, 16] = spot[0:win_size]
        output[0, 16] = 0.0

        # Position 17: HEDGE'S RELATIVE SIZE  (computed at runtime)
        #
        # Hedge position in crypto-units
        # divided by the option notional
        #
        output[:, 17] = 0.0

        # Position 18: ACCOUNT MtM (computed at runtime)
        output[:, 18] = 0.0

        # Position 19: NET DELTA EXPOSURE (computed at runtime)
        output[:, 19] = 0.0

        # Position 20: cur rel pnl wrt max (computed at runtime)
        output[:, 20] = 0.0

        # Position 21: ACCRETION TARGET (computed at runtime)
        output[:, 21] = 0.0
        premium_accretion = initial_cf * np.linspace(0.0, 1.0, self.duration_minutes + 1)
        output[win_size:, 21] = premium_accretion  # np.clip(premium_accretion, 0.0, initial_cf)

        # Check before returning the results
        nan_count = np.count_nonzero(np.isnan(output))
        if nan_count > 0:
            print(f"Found NaN in greek pre-computation.")

        return output.astype(np.float32), initial_cf
